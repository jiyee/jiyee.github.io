<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JSPatch 源码阅读笔记 · Jiyee's I/O</title><meta name="description" content="JSPatch 源码阅读笔记 - Jiyee Sheng"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jiyee.io/atom.xml" title="Jiyee's I/O"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jiyee" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JSPatch 源码阅读笔记</h1><div class="post-info">Dec 23, 2016</div><div class="post-content"><h2 id="v0-0-1"><a href="#v0-0-1" class="headerlink" title="v0.0.1"></a>v0.0.1</h2><p>JSPatch 文件结构简单得让人不可思议，只有 JPEngine{.h,.m} 和 JSPatch.js 三个文件。</p>
<h3 id="JPEngine-h"><a href="#JPEngine-h" class="headerlink" title="JPEngine.h"></a>JPEngine.h</h3><p>JSPatch 依赖 <code>&lt;JavaScriptCore/JavaScriptCore.h&gt;</code> 和 <code>&lt;objc/runtime.h&gt;</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JPEngine</span> : <span class="title">NSObject</span></span></div><div class="line">+ (<span class="keyword">void</span>)startEngine;</div><div class="line">+ (JSValue *)evaluateScript:(<span class="built_in">NSString</span> *)script;</div><div class="line">+ (JSContext *)context;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="JPEngine-m"><a href="#JPEngine-m" class="headerlink" title="JPEngine.m"></a>JPEngine.m</h3><p><code>startEngine</code> 方法里新建并维持一个 JSContext 静态实例，并注入一些 JavaScript 方法和 exceptionHandler，最后在创建的 context 里加载 patch 文件。</p>
<p>注入方法包括：</p>
<ul>
<li>_OC_defineClass</li>
<li>_OC_callI</li>
<li>_OC_callC</li>
<li>_OC_getBlockArguments</li>
<li>_OC_dispatch_after</li>
<li>_OC_dispatch_async_main</li>
<li>_OC_dispatch_sync_main</li>
<li>_OC_dispatch_async_global_queue</li>
<li>_OC_log</li>
<li>_OC_catch</li>
</ul>
<p><code>evaluateScript</code> 方法在 JSContext 类静态实例环境下，执行 patch 文件。其中，多了一步 try/catch 替换工作，把这个 patch 执行体都放在一个 try/catch 方法里，同时，替换 patch 文件里写的 <code>.()</code> 为 <code>.__c()</code>。</p>
<p>有两个属性 <code>cacheArguments</code> 和 <code>cacheArgumentsIdx</code>，作用是 ???</p>
<p>另外，有 5 个全局静态变量 <code>cacheArguments</code>， <code>cacheArgumentsIdx</code>，<code>_propKeys</code>，</p>
<p>这个 JPEngine.m 文件里剩下的基本都是 C 函数。一个个解析如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *propKey(<span class="built_in">NSString</span> *propName)</div></pre></td></tr></table></figure>
<p>Q: 为什么不直接保存 propName，而要转换到 propKey 呢？</p>
<p>读取保存在 _propKeys 字典里 propName 对应的 propKey。在 <code>getPropIMP</code> 和 <code>setPropIMP</code> 方法里被调用，用途是通过 associatedObject 方式给类添加属性。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *defineClass(<span class="built_in">NSString</span> *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)</div></pre></td></tr></table></figure>
<ol>
<li><p>获取定义的类和父类名称，如果类不存在，通过注册 ClassPair 方法注册新类，方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class superCls = <span class="built_in">NSClassFromString</span>(superClassName);</div><div class="line">cls = objc_allocateClassPair(superCls, className.UTF8String, <span class="number">0</span>);</div><div class="line">objc_registerClassPair(cls);</div></pre></td></tr></table></figure>
</li>
<li><p>通过两次循环，遍历实例方法和类方法，通过 <code>class_copyMethodList</code> 函数，遍历类层次结构里已定义的方法，如果存在 jsMethods 里定义的待替换的方法，则调用 <code>overrideMethod</code> 函数完成替换。<br>通过字典保存已替换的方法名，不重复替换。<br>不过，代码中存在循环变量重复定义，没有调用 <code>free</code> 函数等问题。</p>
</li>
<li><p>增加 <code>getProp:</code> 和 <code>setProp:forKey:</code> 方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(getProp:), (IMP)getPropIMP, <span class="string">"@24@0:8@16"</span>);</div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(setProp:forKey:), (IMP)setPropIMP, <span class="string">"v32@0:8@16@24"</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，type encoding 很有意思，待分析？（PS，后续作者去掉了 type 长度限制）</p>
<ol>
<li>返回字典类型结果，包含类，已替换的实例方法，已替换的类方法</li>
</ol>
<p>通过一堆宏定义方法返回类型，例如<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JPMETHOD_IMPLEMENTATION_RET(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="keyword">return</span> [ret toObject])</div></pre></td></tr></table></figure></p>
<p>经过宏展开得到</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> JPMethodImplement_id(<span class="keyword">id</span> slf, SEL selector) &#123;</div><div class="line">  JSValue *fun = getJSFunctionInObjectHierachy(slf, selector);</div><div class="line">  JSValue *ret = [fun callWithArguments:_TMPInvocationArguments];</div><div class="line">  <span class="keyword">id</span> obj = formatJSToOC(ret);</div><div class="line">  <span class="keyword">if</span> (obj == _nilObj || ([obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]] &amp;&amp; strcmp([obj objCType], <span class="string">"c"</span>) == <span class="number">0</span> &amp;&amp; ![obj boolValue]))</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *)<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">  ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JPImplementation 作为 IMP 类型，替换需要 override 的方法。</p>
<h4 id="overrideMethod"><a href="#overrideMethod" class="headerlink" title="overrideMethod"></a>overrideMethod</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> overrideMethod(Class cls, <span class="built_in">NSString</span> *selectorName, JSValue *function, <span class="built_in">BOOL</span> isClassMethod)</div></pre></td></tr></table></figure>
<p><code>__JPNONImplementSelector</code> 不存在的 IMP 实现，用于将待替换的方法走动态消息转发，最终走到 <code>JPForwardInvocation</code> 方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : <span class="literal">NULL</span>;</div><div class="line">class_replaceMethod(cls, selector, class_getMethodImplementation(cls, <span class="keyword">@selector</span>(__JPNONImplementSelector)), typeDescription);</div><div class="line">SEL newForwardSelector = <span class="keyword">@selector</span>(ORIGforwardInvocation:);</div><div class="line"><span class="keyword">if</span> (!class_respondsToSelector(cls, newForwardSelector)) &#123;</div><div class="line">    IMP originalForwardImp = class_replaceMethod(cls, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)JPForwardInvocation, <span class="string">"v@:@"</span>);</div><div class="line">    class_addMethod(cls, newForwardSelector, originalForwardImp, <span class="string">"v@:@"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 <code>forwardInvocation:</code> 就是动态消息转发的原方法，也被替换为 <code>JPForwardInvocation</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将 selector 原实现添加到 ORIGselectorName 新方法</span></div><div class="line"><span class="built_in">NSString</span> *originalSelectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ORIG%@"</span>, selectorName];</div><div class="line">SEL originalSelector = <span class="built_in">NSSelectorFromString</span>(originalSelectorName);</div><div class="line"><span class="keyword">if</span>(!class_respondsToSelector(cls, originalSelector)) &#123;</div><div class="line">    class_addMethod(cls, originalSelector, originalImp, typeDescription);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_methodFunc</div></pre></td></tr></table></figure>
<p>把相关信息传给 Objective-C，Objective-C 用 Runtime 接口调用相应方法，返回结果值。</p>
<p>JSClass 对象包含以下属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__obj <span class="comment">// OC 实例指针</span></div><div class="line">__isSuper <span class="comment">// 是否是 OC 实例的父类</span></div><div class="line">__clsName <span class="comment">// OC 实例对应的类名</span></div><div class="line">__super <span class="comment">// OC 实例的父类的对应的 JSClass 对象</span></div></pre></td></tr></table></figure></p>
<p>阅读 JSPatch 的 JavaScript 代码应从 patch 示例代码入手，直接从 JSPatch.js 入手的话，很多代码看起来不知为何缘由，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'UIView'</span>)</div></pre></td></tr></table></figure></p>
<p>首先，<code>require</code> 方法是定义在 global 全局对象上的自定义方法，调用了 <code>_require</code> 内部方法，在 global 全局对象上定义了 <code>UIView</code> 这个属性，保存了对应的一个对象 <code>{__isCls: 1, __clsName: &#39;UIView&#39;}</code>。这样，至此就能调用 <code>UIView</code> 这个全局属性了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">global.defineClass = <span class="function"><span class="keyword">function</span>(<span class="params">declaration, instMethods, clsMethods</span>) </span>&#123;</div><div class="line">  <span class="comment">// 包装传入的函数，参数类型转换</span></div><div class="line">  <span class="keyword">var</span> newInstMethods = &#123;&#125;, newClsMethods = &#123;&#125;</div><div class="line">  _formatDefineMethod(instMethods, newInstMethods, <span class="number">1</span>)</div><div class="line">  _formatDefineMethod(clsMethods, newClsMethods, <span class="number">0</span>)</div><div class="line"></div><div class="line">  <span class="comment">// 调用 JSContext 定义的 _OC_defineClass 方法，执行方法替换</span></div><div class="line">  <span class="comment">// 返回的 JS 对象包含类名 cls，实例方法名数组 instMethods，类方法名数组 clsMethods</span></div><div class="line">  <span class="keyword">var</span> ret = _OC_defineClass(declaration, newInstMethods, newClsMethods)</div><div class="line"></div><div class="line">  <span class="comment">// 剔除 OC 已替换的方法，剩下的是 JS 本地方法，重置这些方法执行时上下文环境和参数类型</span></div><div class="line">  _formatLocalMethods(instMethods, ret[<span class="string">"instMethods"</span>], <span class="number">1</span>)</div><div class="line">  _formatLocalMethods(clsMethods, ret[<span class="string">"clsMethods"</span>], <span class="number">1</span>)</div><div class="line"></div><div class="line">  <span class="comment">// 按类保存定义的实例方法和类方法</span></div><div class="line">  localMethods[ret[<span class="string">"cls"</span>]] = &#123;</div><div class="line">    <span class="attr">instMethods</span>: instMethods,</div><div class="line">    <span class="attr">clsMethods</span>: clsMethods</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(ret[<span class="string">"cls"</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>defineClass 方法用于在 JS 里定义 OC 类，类方法和实例方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _formatDefineMethod = <span class="function"><span class="keyword">function</span>(<span class="params">methods, newMethods, isInst</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> methodName <span class="keyword">in</span> methods) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> originMethod = methods[methodName]</div><div class="line">      newMethods[methodName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = _formatOCToJS(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</div><div class="line">        <span class="keyword">if</span> (isInst) &#123;</div><div class="line">          global.self = args[<span class="number">0</span>]</div><div class="line">          args.splice(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> ret = _formatJSToOC(originMethod.apply(originMethod, args))</div><div class="line">        <span class="keyword">if</span> (isInst) &#123;</div><div class="line">          global.self = <span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret</div><div class="line">      &#125;</div><div class="line">    &#125;)()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要做两件事，一是将传入的 OC 参数转换成 JSClass 对象，调用定义的 JS 方法，再将 JS 返回结果转换成 OC 对象。二是如果实例方法调用，在调用前后设置 <code>global.self</code> 属性，让 JS 写的代码也能像 OC 一样有 self 属性，而 self 属性的值就是执行方法实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _formatOCToJS = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (obj === <span class="literal">undefined</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></div><div class="line"></div><div class="line">   <span class="comment">// 如果是 OC 返回的对象，则包含 __isObj 属性，重新封装成 JSClass 对象</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> obj == <span class="string">"object"</span> &amp;&amp; obj.__isObj) &#123;</div><div class="line">     <span class="keyword">return</span> _toJSObj(obj)</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 如果是数组，递归处理</span></div><div class="line">   <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line">      <span class="keyword">var</span> ret = []</div><div class="line">      obj.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">        ret.push(_formatOCToJS(o))</div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">return</span> ret</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 如果是方法，则包装一个新方法，将其传入参数转换类型</span></div><div class="line">   <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</div><div class="line">        obj.apply(obj, _formatJSToOC(args))</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 如果是 JS 对象，则遍历全部属性值，进行类型转换</span></div><div class="line">   <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</div><div class="line">      <span class="keyword">var</span> ret = &#123;&#125;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">        ret[key] = _formatOCToJS(obj[key])</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> ret</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 其他基本数据类型，则不处理</span></div><div class="line">   <span class="keyword">return</span> obj</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _formatJSToOC = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">   <span class="comment">// 如果是 JSClass 对象，则返回 OC 对象指针</span></div><div class="line">   <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> &amp;&amp; obj.__obj) &#123;</div><div class="line">     <span class="keyword">return</span> obj.__obj</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 如果是数组，递归处理</span></div><div class="line">   <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line">      <span class="keyword">var</span> ret = []</div><div class="line">      obj.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">        ret.push(_formatJSToOC(o))</div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">return</span> ret</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 如果是 JS 对象，则遍历全部属性值，进行类型转换</span></div><div class="line">   <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</div><div class="line">      <span class="keyword">var</span> ret = &#123;&#125;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</div><div class="line">          ret[key] = _formatJSToOC(obj[key])</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> ret</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 其他类型，则不处理</span></div><div class="line">   <span class="keyword">return</span> obj</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _formatLocalMethods = <span class="function"><span class="keyword">function</span>(<span class="params">methods, ocMethods, isInst</span>) </span>&#123;</div><div class="line">  ocMethods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">methodName</span>)</span>&#123;</div><div class="line">    <span class="keyword">delete</span> methods[methodName]</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> methodName <span class="keyword">in</span> methods) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> originMethod = methods[methodName]</div><div class="line">      methods[methodName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</div><div class="line">        <span class="keyword">if</span> (isInst) global.self = <span class="keyword">this</span></div><div class="line">        <span class="keyword">var</span> ret = originMethod.apply(<span class="keyword">this</span>, args)</div><div class="line">        <span class="keyword">if</span> (isInst) global.self = <span class="literal">null</span></div><div class="line">        <span class="keyword">return</span> ret</div><div class="line">      &#125;</div><div class="line">    &#125;)()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给全部 JS 对象加上 __c 方法，调用 __c 方法之后返回的还是方法</span></div><div class="line"><span class="built_in">Object</span>.prototype.__c = <span class="function"><span class="keyword">function</span>(<span class="params">methodName</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果不是 JSClass 对象，则直接调用方法，表示调用的是 JS 原生方法，绑定作用域</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.__obj &amp;&amp; !<span class="keyword">this</span>.__clsName) <span class="keyword">return</span> <span class="keyword">this</span>[methodName].bind(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 从定义的类的 JS 方法里查找，如果存在则是 JS 定义方法，绑定作用域</span></div><div class="line">  <span class="keyword">var</span> customMethod = _getCustomMethod(<span class="keyword">this</span>.__clsName, methodName, !!<span class="keyword">this</span>.__obj)</div><div class="line">  <span class="keyword">if</span> (customMethod) &#123;</div><div class="line">    <span class="keyword">return</span> customMethod.bind(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">  <span class="comment">// 返回包装方法，方法里代理到对应的 OC 类的实例方法或类方法</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</div><div class="line">    <span class="keyword">return</span> _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 命名不是很直观，看了多遍之后才反应过来，method 对应的 OC 方法，func 对应的 JS 方法，只能说作者很用心，我领悟能力有限</span></div><div class="line"><span class="keyword">var</span> _methodFunc = <span class="function"><span class="keyword">function</span>(<span class="params">instance, clsName, methodName, args, isSuper</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = _formatJSToOC(args)</div><div class="line"></div><div class="line">  <span class="comment">// 方法名替换， indexPathForRow_inSection 到 indexPathForRow:inSection: 格式</span></div><div class="line">  <span class="keyword">var</span> selectorName = methodName.replace(<span class="regexp">/_/g</span>, <span class="string">":"</span>)</div><div class="line">  <span class="keyword">var</span> marchArr = selectorName.match(<span class="regexp">/:/g</span>)</div><div class="line">  <span class="keyword">var</span> numOfArgs = marchArr ? marchArr.length : <span class="number">0</span></div><div class="line">  <span class="comment">// 判断是否是无参方法，如果不是补全冒号</span></div><div class="line">  <span class="keyword">if</span> (args.length &gt; numOfArgs) &#123;</div><div class="line">    selectorName += <span class="string">":"</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 代理调用 OC 方法</span></div><div class="line">  <span class="keyword">var</span> ret = instance ? _OC_callI(instance, selectorName, args, isSuper):</div><div class="line">                       _OC_callC(clsName, selectorName, args)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> _formatOCToJS(ret)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="阅读感受："><a href="#阅读感受：" class="headerlink" title="阅读感受："></a>阅读感受：</h3><p>我是先看的源码，再仔细看的 bang 的文章，文章写的很通俗易懂。在没有看详解文章之前，每个方法基本都能看懂，但是方法之间的关联和部分方法为什么要这么处理还不能很好的反向理解。另外，看的过程中觉得能写出这么多闭包和作用域绑定的 JavaScript 代码看起来很牛逼，普通的 iOS 程序员肯定是达不到这个水平的，看了博客之后才发现 bang 原来做过前端，好吧。。。跨界才是 iOS 的未来。</p>
<p>v0.0.1 的单元测试还仅仅覆盖通过 JS 创建和传递不同类型的对象，通过 JS 调用 OC 方法等。测试用例的写法比较独特，都是通过对象 BOOL 属性标识来判断单个测试是否正确执行，需要按顺序来阅读测试用例，测试代码和断言代码分布在不同文件，需要跳跃着来阅读。</p>
<p>另外，觉得 v0.0.1 代码整体缺乏优雅的结构，看起来很累，代码本身也没有太多注释，代码中还遗留了不少错误。不过更新很快，而且越来越多的代码贡献都来自社区。总而言之，JSPatch 的出现给社区提供了一个很不错的平台基础，给沉寂已久的 iOS 社区注入了一股清流。</p>
<h2 id="v0-0-2"><a href="#v0-0-2" class="headerlink" title="v0.0.2"></a>v0.0.2</h2><h3 id="版本动态"><a href="#版本动态" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>支持添加新的 OC 方法，<a href="https://github.com/bang590/JSPatch/commit/653074ff50639c57703265c4824b604c7bc80127" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/653074ff50639c57703265c4824b604c7bc80127</a></li>
<li>方法名包含下划线 ‘_’，JS 用 ‘__’ 表示</li>
<li><a href="https://github.com/bang590/JSPatch/pull/17" target="_blank" rel="external">https://github.com/bang590/JSPatch/pull/17</a></li>
<li>_objc_msgForward，<a href="https://github.com/bang590/JSPatch/commit/e67740fc386dd205d254da141d4480c4396b0c7d，https://github.com/bang590/JSPatch/commit/770d4efaf7d4ab1194d756dff65b0bfc79908c7c" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/e67740fc386dd205d254da141d4480c4396b0c7d，https://github.com/bang590/JSPatch/commit/770d4efaf7d4ab1194d756dff65b0bfc79908c7c</a></li>
<li>支持 NSNull 和 nil 参数，<a href="https://github.com/bang590/JSPatch/commit/5f2f081d9b75a3719e53d9c40eae48e2252a0934" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/5f2f081d9b75a3719e53d9c40eae48e2252a0934</a></li>
</ul>
<p>关于 <code>_objc_msgForward</code> 用途，进一步阅读 <a href="http://www.jianshu.com/p/3c8ce231576c" target="_blank" rel="external">http://www.jianshu.com/p/3c8ce231576c</a></p>
<h4 id="支持添加新的-OC-方法，addNewMethod"><a href="#支持添加新的-OC-方法，addNewMethod" class="headerlink" title="支持添加新的 OC 方法，addNewMethod"></a>支持添加新的 OC 方法，addNewMethod</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> addNewMethod(Class cls, <span class="built_in">NSString</span> *selectorName, JSValue *function, <span class="keyword">int</span> argCount, <span class="built_in">BOOL</span> isClassMethod) &#123;</div><div class="line">    <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(cls);</div><div class="line">    <span class="comment">// 重构 methods 存储方式，不再区分类方法和实例方法，按类名和方法名存储为二维数组</span></div><div class="line">    _initJPOverideMethods(clsName);</div><div class="line">    _JSOverideMethods[clsName][selectorName] = function;</div><div class="line"></div><div class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line"></div><div class="line">    <span class="comment">// 跟进参数格式指定不同的 IMP，IMP 的第一个参数是 id self， 第二个参数是  SEL selector，后续才是调用参数</span></div><div class="line">    IMP JPImplementation = (IMP)JPMETHOD_NEW_IMPLEMENTATION_NAME(<span class="number">0</span>);</div><div class="line">    <span class="keyword">switch</span> (argCount) &#123;</div><div class="line">    <span class="meta">#define JPMETHOD_NEW_CASE(_argCount) \</span></div><div class="line">        <span class="keyword">case</span> _argCount: \</div><div class="line">            JPImplementation = (IMP)JPMETHOD_NEW_IMPLEMENTATION_NAME(_argCount);    \</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        JPMETHOD_NEW_CASE(<span class="number">0</span>)</div><div class="line">        JPMETHOD_NEW_CASE(<span class="number">1</span>)</div><div class="line">        JPMETHOD_NEW_CASE(<span class="number">2</span>)</div><div class="line">        JPMETHOD_NEW_CASE(<span class="number">3</span>)</div><div class="line">        JPMETHOD_NEW_CASE(<span class="number">4</span>)</div><div class="line">        JPMETHOD_NEW_CASE(<span class="number">5</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据参数个数设置 type encoding</span></div><div class="line">    <span class="built_in">NSMutableString</span> *typeDescStr = [<span class="string">@"@@:"</span> mutableCopy];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argCount; i ++) &#123;</div><div class="line">        [typeDescStr appendString:<span class="string">@"@"</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调用 class_addMethod 方法添加新的方法，class_addMethod 会重写父类同名实现，但是不会替换类已有实现</span></div><div class="line">    class_addMethod(cls, selector, JPImplementation, [typeDescStr cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于统一了对象和方法的存储方式，在对象层次结构上查找定义的 JS 方法变得更简单。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> JSValue* getJSFunctionInObjectHierarchy(<span class="keyword">id</span> slf, SEL selector) &#123;</div><div class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</div><div class="line">    Class cls = [slf <span class="keyword">class</span>];</div><div class="line">    <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(cls);</div><div class="line">    JSValue *func = _JSOverideMethods[clsName][selectorName];</div><div class="line">    <span class="keyword">while</span> (!func) &#123;</div><div class="line">        cls = class_getSuperclass(cls);</div><div class="line">        <span class="keyword">if</span> (!cls) &#123;</div><div class="line">            <span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"warning can not find selector %@"</span>, selectorName);</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        clsName = <span class="built_in">NSStringFromClass</span>(cls);</div><div class="line">        func = _JSOverideMethods[clsName][selectorName];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="objc-msgForward-替换-JPNONImplementSelector"><a href="#objc-msgForward-替换-JPNONImplementSelector" class="headerlink" title="- _objc_msgForward 替换 __JPNONImplementSelector"></a>- _objc_msgForward 替换 __JPNONImplementSelector</h4><p>在 forwardInvocation 逻辑里，把它指向了一个不存在的 IMP，之前的实现是指定一个不存在的 selector，而 class_getMethodImplementation 函数在找不到 selector 对应的 IMP 时，会返回 <code>_objc_msgForward</code> 这个 IMP，所以优化成直接指向这个 IMP。</p>
<p>另外，一个 bugfix 还不太看得懂代码，就是处理非 64 位处理器 IMP 返回一个 struct 时的崩溃，具体原理解释参看 <a href="http://blog.cnbang.net/tech/2855/。另外，在" target="_blank" rel="external">http://blog.cnbang.net/tech/2855/。另外，在</a> Aspects 这个项目里也找到了同样的处理，不过代码更加清晰。<a href="https://github.com/steipete/Aspects/blob/master/Aspects.m#L243" target="_blank" rel="external">https://github.com/steipete/Aspects/blob/master/Aspects.m#L243</a></p>
<h4 id="支持-NSNull-和-nil-参数"><a href="#支持-NSNull-和-nil-参数" class="headerlink" title="支持 NSNull 和 nil 参数"></a>支持 NSNull 和 nil 参数</h4><p>把 nil 参数在内部处理成 NSNull，而 NSNull 在转成 JS 对象是增加 <code>__isNull</code> 属性。</p>
<h2 id="v0-0-3"><a href="#v0-0-3" class="headerlink" title="v0.0.3"></a>v0.0.3</h2><h3 id="版本动态-1"><a href="#版本动态-1" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>修复多线程调用的问题，通过同步锁解决，<a href="https://github.com/bang590/JSPatch/issues/21" target="_blank" rel="external">https://github.com/bang590/JSPatch/issues/21</a></li>
<li>进一步支持参数传入 null， undefined， nsnull， <a href="https://github.com/bang590/JSPatch/issues/31" target="_blank" rel="external">https://github.com/bang590/JSPatch/issues/31</a></li>
<li><strong>支持调用 NSArray / NSDictionary / NSString 的方法</strong>，<a href="https://github.com/bang590/JSPatch/commit/e6b121db3feacb22e7bbf81d2be67811e4558fd3，https://github.com/bang590/JSPatch/commit/73569a1041242bb1d88b7b0ee1c69d69548ad98c" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/e6b121db3feacb22e7bbf81d2be67811e4558fd3，https://github.com/bang590/JSPatch/commit/73569a1041242bb1d88b7b0ee1c69d69548ad98c</a></li>
<li><strong>支持 Protocol</strong></li>
<li>这个版本开始单元测试逐步覆盖比较完整了</li>
</ul>
<h4 id="支持调用-NSArray-NSDictionary-NSString-的方法"><a href="#支持调用-NSArray-NSDictionary-NSString-的方法" class="headerlink" title="支持调用 NSArray / NSDictionary / NSString 的方法"></a><strong>支持调用 NSArray / NSDictionary / NSString 的方法</strong></h4><blockquote>
<p>API changes:<br>1.now the NSArray/NSDictionary/NSString will use as NSObject in JS instead of JS type.<br>2.use .toJS() to transfer NSArray/NSDictionary/NSString to JS array/object/string.<br>3.change API .super to .super()</p>
<p>Code changes:<br>1.box/unbox for NSArray/NSDictionary/NSString<br>2.remove JSClass<br>3.move formatJSToOC() to Objective-C</p>
</blockquote>
<p>目的是为了在写 Patch 的时候一直保留 OC API，将方法调用的返回值都返回包装类型，避免 JS 和 OC 的 API 混用。另一方面，优化了 JS 调用 OC 方法时参数装箱，调用返回时返回值拆箱的处理，提升了性能。<br>装箱拆箱的设计很多语言里都有，这里的设计是返回 JSBoxing，移除了原有的 JSClass 设计，在 JS 层面就变得更轻巧，而且将原本在 JS 处理的 _formatJSToOC 方法实现移至了 OC 实现，而保留在 JS 的 <code>_formatOCToJS</code> 方法，仅仅是递归拆包处理。另外，JS 里也移除了 <code>localMethods</code> 的解析和保存。<br>装箱支持 id，void <em>，Class，SEL 类型，void </em> 指针类型支持 _OC_free / free 方法释放。</p>
<h4 id="支持-Protocol"><a href="#支持-Protocol" class="headerlink" title="支持 Protocol"></a><strong>支持 Protocol</strong></h4><p>这样做的作用是，当添加 Protocol 里定义的方法，而类里没有实现的方法时，参数和返回值类型不再全是 id，而是自动转为 Protocol 里定义的类型。<br>具体实现上，差别就在于 <code>overrideMethod</code> 方法里传入匹配的 typeDescription。原本 typeDescription 获取是通过 selectorName -&gt; SEL -&gt; Method -&gt; method type encoding 方式，methodSignature 获取是通过 instanceMethodSignatureForSelector 方法。现在，有了 typeDescription 之后，直接通过 signatureWithObjCTypes 方法就能获取 methodSignature。<br>我的理解是，代码里混用了 typeDescption 和 methodSignature，比较乱。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> *methodTypesInProtocol(<span class="built_in">NSString</span> *protocolName, <span class="built_in">NSString</span> *selectorName, <span class="built_in">BOOL</span> isInstanceMethod, <span class="built_in">BOOL</span> isRequired) &#123;</div><div class="line">    Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> selCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 获取到接口里定义的方法描述</span></div><div class="line">    <span class="keyword">struct</span> objc_method_description *methods = protocol_copyMethodDescriptionList(protocol, isRequired, isInstanceMethod, &amp;selCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selCount; i ++) &#123;</div><div class="line">        <span class="keyword">if</span> ([selectorName isEqualToString:<span class="built_in">NSStringFromSelector</span>(methods[i].name)]) &#123;</div><div class="line">            <span class="keyword">return</span> methods[i].types;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> 缺少 free(methods) 调用</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="v0-1"><a href="#v0-1" class="headerlink" title="v0.1"></a>v0.1</h2><h3 id="版本动态-2"><a href="#版本动态-2" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>取消了 addNewMethod 方法，合并到 overrideMethod 方法</li>
<li>支持链式调用，通过返回 false 实现</li>
<li>使用 JSValue 原生方法转换 CGRect/CGSize/CGPoint/NSRange struct</li>
<li>规范定义了 Extension 机制</li>
<li>增加了 C 接口扩展，这一个版本 albert438 贡献不少代码，他的博客里也有不少介绍 JSPatch 原理的文章</li>
<li>增加了 JPMemory 扩展，用于 JS 里直接操作内存和结构体分配</li>
</ul>
<h4 id="判断-selector-是否被替换的方法"><a href="#判断-selector-是否被替换的方法" class="headerlink" title="判断 selector 是否被替换的方法"></a>判断 selector 是否被替换的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class_getMethodImplementation(cls, <span class="keyword">@selector</span>(forwardInvocation:)) != (IMP)JPForwardInvocation</div></pre></td></tr></table></figure>
<h4 id="取消了-addNewMethod-方法，合并到-overrideMethod-方法"><a href="#取消了-addNewMethod-方法，合并到-overrideMethod-方法" class="headerlink" title="取消了 addNewMethod 方法，合并到 overrideMethod 方法"></a>取消了 addNewMethod 方法，合并到 overrideMethod 方法</h4><p>因为 <code>class_replaceMethod</code> 有两个表现，如 API 文档描述：</p>
<blockquote>
<p>This function behaves in two different ways:</p>
<p>If the method identified by name does not yet exist, it is added as if class_addMethod were called. The type encoding specified by types is used as given.</p>
<p>If the method identified by name does exist, its IMP is replaced as if method_setImplementation were called. The type encoding specified by types is ignored.</p>
</blockquote>
<p>只要传入合适的 types，即可作为 <code>class_addMethod</code> 使用。</p>
<h4 id="支持链式调用，通过返回-false-实现"><a href="#支持链式调用，通过返回-false-实现" class="headerlink" title="支持链式调用，通过返回 false 实现"></a>支持链式调用，通过返回 false 实现</h4><p><a href="https://github.com/bang590/JSPatch/commit/cb7688ee74c3bbc88f0a80c72b1864a93e918f66" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/cb7688ee74c3bbc88f0a80c72b1864a93e918f66</a></p>
<p>这个 bang 的文章里有详细解释，实现上来讲也很巧妙。</p>
<p>同时，支持了 nil 类型，实现方式上同 NULL 类型。</p>
<h4 id="使用-JSValue-原生方法转换-CGRect-CGSize-CGPoint-NSRange-struct"><a href="#使用-JSValue-原生方法转换-CGRect-CGSize-CGPoint-NSRange-struct" class="headerlink" title="使用 JSValue 原生方法转换 CGRect/CGSize/CGPoint/NSRange struct"></a>使用 JSValue 原生方法转换 CGRect/CGSize/CGPoint/NSRange struct</h4><p><a href="https://github.com/bang590/JSPatch/commit/3228c85b68ec675b65ace95119d6f7b3df5e2243" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/3228c85b68ec675b65ace95119d6f7b3df5e2243</a></p>
<p>这个 commit 也挺有意思的，bang 发现了 JSValue 原生方法就支持转换 CGRect/CGSize/CGPoint/NSRange struct，免去了额外的扩展支持。从侧面也说明对于 Apple API 越了解越能发现简单的解决方式，上述的 <code>class_replaceMethod</code> 同理。</p>
<h4 id="规范定义了-Extension-机制"><a href="#规范定义了-Extension-机制" class="headerlink" title="规范定义了 Extension 机制"></a>规范定义了 Extension 机制</h4><p>Extension 扩展机制保证了核心代码的精简和稳定。</p>
<p>bang 的文章里解释了 Extension 接口设计的目标：</p>
<ul>
<li>接口清晰</li>
<li>每个扩展独立存在，互不影响</li>
<li>不影响JPEngine的正常使用，尽量少暴露JPEngine的接口</li>
<li>扩展的接口可扩展，以后有其他扩展需求可以在其基础上添加</li>
<li>动态加载，扩展可能会给JS全局变量添加很多接口，最好能在真正使用到时才加载</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JPExtensionProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)main:(JSContext *)context;</div><div class="line"></div><div class="line">- (size_t)sizeOfStructWithTypeName:(<span class="built_in">NSString</span> *)typeName;</div><div class="line">- (<span class="built_in">NSDictionary</span> *)dictOfStruct:(<span class="keyword">void</span> *)structData typeName:(<span class="built_in">NSString</span> *)typeName;</div><div class="line">- (<span class="keyword">void</span>)structData:(<span class="keyword">void</span> *)structData ofDict:(<span class="built_in">NSDictionary</span> *)dict typeName:(<span class="built_in">NSString</span> *)typeName;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JPExtension</span> : <span class="title">NSObject</span> &lt;<span class="title">JPExtensionProtocol</span>&gt;</span></div><div class="line">+ (<span class="keyword">instancetype</span>)instance;</div><div class="line">- (<span class="keyword">void</span> *)formatPointerJSToOC:(JSValue *)val;</div><div class="line">- (<span class="keyword">id</span>)formatPointerOCToJS:(<span class="keyword">void</span> *)pointer;</div><div class="line">- (<span class="keyword">id</span>)formatJSToOC:(JSValue *)val;</div><div class="line">- (<span class="keyword">id</span>)formatOCToJS:(<span class="keyword">id</span>)obj;</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> formatJSToOC(JSValue *val);</div><div class="line"><span class="keyword">id</span> formatOCToJS(<span class="keyword">id</span> obj);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JPExtension</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)instance &#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span> *)formatPointerJSToOC:(JSValue *)val &#123;</div><div class="line">    <span class="keyword">id</span> obj = [val toObject];</div><div class="line">    <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123; <span class="comment">// 包装对象</span></div><div class="line">        <span class="keyword">if</span> (obj[<span class="string">@"__obj"</span>] &amp;&amp; [obj[<span class="string">@"__obj"</span>] isKindOfClass:[JPBoxing <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="keyword">return</span> [(JPBoxing *)(obj[<span class="string">@"__obj"</span>]) unboxPointer];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![val toBool]) &#123; <span class="comment">// false</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125; <span class="keyword">else</span>&#123; <span class="comment">// JPBoxing</span></div><div class="line">        <span class="keyword">return</span> [((JPBoxing *)[val toObject]) unboxPointer];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)formatPointerOCToJS:(<span class="keyword">void</span> *)pointer &#123;</div><div class="line">    <span class="keyword">return</span> formatOCToJS([JPBoxing boxPointer:pointer]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)formatJSToOC:(JSValue *)val &#123;</div><div class="line">    <span class="keyword">if</span> (![val toBool]) &#123; <span class="comment">// false</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> formatJSToOC(val);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)formatOCToJS:(<span class="keyword">id</span>)obj &#123;</div><div class="line">    <span class="comment">// 疑问，为什么代理给 JS 方法去执行？</span></div><div class="line">    <span class="comment">// Unified the return value of C API</span></div><div class="line">Extensions and Objective-C method.</div><div class="line">    <span class="keyword">return</span> [[JSContext currentContext][<span class="string">@"_formatOCToJS"</span>] callWithArguments:@[formatOCToJS(obj)]];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在实现中区分了 extensions 和 structExtensions。</p>
<h4 id="增加了-JPMemory-扩展，用于-JS-里直接操作内存和结构体分配"><a href="#增加了-JPMemory-扩展，用于-JS-里直接操作内存和结构体分配" class="headerlink" title="增加了 JPMemory 扩展，用于 JS 里直接操作内存和结构体分配"></a>增加了 JPMemory 扩展，用于 JS 里直接操作内存和结构体分配</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">context[<span class="string">@"getPointer"</span>] = ^<span class="keyword">id</span>(JSValue *jsVal) &#123;</div><div class="line">    <span class="keyword">void</span> **p = malloc(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line">    <span class="keyword">void</span> *pointer = [<span class="keyword">self</span> formatPointerJSToOC:jsVal];</div><div class="line">    <span class="keyword">if</span> (pointer != <span class="literal">NULL</span>) &#123;</div><div class="line">        *p = pointer;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">id</span> obj = [<span class="keyword">self</span> formatJSToOC:jsVal];</div><div class="line">        *p = (__bridge <span class="keyword">void</span>*)obj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> formatPointerOCToJS:p];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>存在一个没看懂的代码，为什么不是 <code>void *p = malloc(sizeof(void));</code>，而需要定义成 <code>void **</code>？</p>
<h2 id="v0-1-1"><a href="#v0-1-1" class="headerlink" title="v0.1.1"></a>v0.1.1</h2><h3 id="版本动态-3"><a href="#版本动态-3" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>性能提升，调用 Patch 方法时，直接处理 invocation</li>
<li>增加 <strong>weak() 和 </strong>strong() 接口</li>
<li>增加 JPStructPointer，支持定义结构体，根据结构体指针和 key 获取 value 的方法，以及 struct 和 NSDictionry 直接的互转方法</li>
<li>增加 performSelector() 接口，直接调用 OC 方法</li>
</ul>
<h4 id="性能提升，调用-Patch-方法时，直接处理-invocation"><a href="#性能提升，调用-Patch-方法时，直接处理-invocation" class="headerlink" title="性能提升，调用 Patch 方法时，直接处理 invocation"></a>性能提升，调用 Patch 方法时，直接处理 invocation</h4><p><a href="https://github.com/bang590/JSPatch/commit/60266cb3456585b4a9a3e4b7bd83b2955b988595" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/60266cb3456585b4a9a3e4b7bd83b2955b988595</a></p>
<p>在 overrideMethod 阶段，将 JPSelector 方法也指向 msgForwardIMP，不再指向自定义方法。</p>
<p>在 JPForwardInvocation 阶段，如果调用的是 JPSelector 方法，则转发到 ORIGforwardInovation。返回时，不再调用指向 JPSelector 方法的 inovation，而是直接组装好 setReturnValue。</p>
<h4 id="增加-weak-和-strong-接口"><a href="#增加-weak-和-strong-接口" class="headerlink" title="增加 weak() 和 strong() 接口"></a>增加 <strong>weak() 和 </strong>strong() 接口</h4><p>通过 JPBoxing 里增加 weak 类型的 weakObj 引用来保存。<br>至于实现细节还没有理清楚。</p>
<h4 id="增加-JPStructPointer，支持定义结构体，根据结构体指针和-key-获取-value-的方法，以及-struct-和-NSDictionry-直接的互转方法"><a href="#增加-JPStructPointer，支持定义结构体，根据结构体指针和-key-获取-value-的方法，以及-struct-和-NSDictionry-直接的互转方法" class="headerlink" title="增加 JPStructPointer，支持定义结构体，根据结构体指针和 key 获取 value 的方法，以及 struct 和 NSDictionry 直接的互转方法"></a>增加 JPStructPointer，支持定义结构体，根据结构体指针和 key 获取 value 的方法，以及 struct 和 NSDictionry 直接的互转方法</h4><h4 id="增加-performSelector-接口，直接调用-OC-方法"><a href="#增加-performSelector-接口，直接调用-OC-方法" class="headerlink" title="增加 performSelector() 接口，直接调用 OC 方法"></a>增加 performSelector() 接口，直接调用 OC 方法</h4><h4 id="给-MethodSignature-增加-Cache"><a href="#给-MethodSignature-增加-Cache" class="headerlink" title="给 MethodSignature 增加 Cache"></a>给 MethodSignature 增加 Cache</h4><p>Caching the MethodSignature when calling Objective-C methods in JavaScript. Make the performance 25% faster than before.</p>
<p><a href="https://github.com/bang590/JSPatch/commit/370b8d3b62639de21750f4b9a9668f0abd842591" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/370b8d3b62639de21750f4b9a9668f0abd842591</a></p>
<p>性能的瓶颈在于 <code>methodSignature = [cls instanceMethodSignatureForSelector:selector];</code> 方法调用？怎么定位的性能问题？</p>
<h2 id="v0-1-3"><a href="#v0-1-3" class="headerlink" title="v0.1.3"></a>v0.1.3</h2><h3 id="版本动态-4"><a href="#版本动态-4" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>完善 console.log 方法</li>
</ul>
<h4 id="完善-console-log-方法"><a href="#完善-console-log-方法" class="headerlink" title="完善 console.log 方法"></a>完善 console.log 方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (global.console) &#123;</div><div class="line">  <span class="keyword">var</span> jsLogger = <span class="built_in">console</span>.log;</div><div class="line">  <span class="comment">// 重新包装 console.log 方法，既执行 _OC_log 用于 NSLog 输出，又执行 log 方法用于控制台输出</span></div><div class="line">  global.console.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    global._OC_log.apply(global, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">if</span> (jsLogger) &#123;</div><div class="line">      jsLogger.apply(global.console, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  global.console = &#123;</div><div class="line">    <span class="attr">log</span>: global._OC_log</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比最初的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">global.console = &#123;</div><div class="line">  <span class="attr">log</span>: global._OC_log</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="v0-1-4"><a href="#v0-1-4" class="headerlink" title="v0.1.4"></a>v0.1.4</h2><h3 id="版本动态-5"><a href="#版本动态-5" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>增加性能测试 Case，采用 measureBlock: 方法，测试各种替换，执行，包括 JS 方法和 OC 方法</li>
<li>性能提升，通过 NSRecursiveLock 和 NSLock 替换 @synchronized</li>
<li>增加了 __bridge_id() 和 CFRelease() 接口</li>
<li>修复内存泄漏</li>
<li>支持 JS 自定义结构体作为参数和返回值使用</li>
</ul>
<h4 id="增加性能测试-Case"><a href="#增加性能测试-Case" class="headerlink" title="增加性能测试 Case"></a>增加性能测试 Case</h4><p>性能 Case 在执行 10000 次的基准下，基本在 0.2s 以内</p>
<h4 id="性能提升，通过-NSRecursiveLock-和-NSLock-替换-synchronized"><a href="#性能提升，通过-NSRecursiveLock-和-NSLock-替换-synchronized" class="headerlink" title="性能提升，通过 NSRecursiveLock 和 NSLock 替换 @synchronized"></a>性能提升，通过 NSRecursiveLock 和 NSLock 替换 @synchronized</h4><p><a href="https://github.com/bang590/JSPatch/commit/72717d81b556df80bc4c84ddb303da063b584bc2" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/72717d81b556df80bc4c84ddb303da063b584bc2</a></p>
<p>NSRecursiveLock 和 NSLock 在使用选择上有什么差别？</p>
<h4 id="增加了-bridge-id-和-CFRelease-接口"><a href="#增加了-bridge-id-和-CFRelease-接口" class="headerlink" title="增加了 __bridge_id() 和 CFRelease() 接口"></a>增加了 __bridge_id() 和 CFRelease() 接口</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">context[<span class="string">@"__bridge_id"</span>] = ^<span class="keyword">id</span>(JSValue *jsVal) &#123;</div><div class="line">    <span class="keyword">void</span> *p = [<span class="keyword">self</span> formatPointerJSToOC:jsVal];</div><div class="line">    <span class="keyword">id</span> obj = (__bridge <span class="keyword">id</span>)p;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> formatOCToJS:obj];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">context[<span class="string">@"CFRelease"</span>] = ^<span class="keyword">void</span>(JSValue *jsVal) &#123;</div><div class="line">    <span class="built_in">CFRelease</span>([<span class="keyword">self</span> formatPointerJSToOC:jsVal]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>为什么 <strong>weak 不像 </strong>bridge_id 一样实现？</p>
<h4 id="修复内存泄漏"><a href="#修复内存泄漏" class="headerlink" title="修复内存泄漏"></a>修复内存泄漏</h4><p>终于修复了在 0.0.1 就引入的内存泄漏问题，也取消了 typeDescription 和 methodSignature 混用。</p>
<p><a href="https://github.com/bang590/JSPatch/commit/799d70c5a973265790fecf623a6639be39a59459" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/799d70c5a973265790fecf623a6639be39a59459</a></p>
<p><a href="https://github.com/bang590/JSPatch/commit/5d5208668b9d287df971966034680426572aae96" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/5d5208668b9d287df971966034680426572aae96</a></p>
<h4 id="支持自定义结构体作为参数和返回值使用"><a href="#支持自定义结构体作为参数和返回值使用" class="headerlink" title="支持自定义结构体作为参数和返回值使用"></a>支持自定义结构体作为参数和返回值使用</h4><p>将传入的自定义结构体包装成 JSValue</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[argList addObject:[JSValue valueWithObject:dict inContext:_context]];</div></pre></td></tr></table></figure>
<p>设置返回值时，解析类型，创建 <code>void *</code> 指针，指向结构体。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span> (_context) &#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *structDefine = registeredStruct[typeString];</div><div class="line">    <span class="keyword">if</span> (structDefine) &#123;</div><div class="line">        size_t size = sizeOfStructTypes(structDefine[<span class="string">@"types"</span>]);</div><div class="line">        JP_FWD_RET_CALL_JS</div><div class="line">        <span class="keyword">void</span> *ret = malloc(size);</div><div class="line">        <span class="built_in">NSDictionary</span> *dict = formatJSToOC(jsval);</div><div class="line">        getStructDataWithDict(ret, dict, structDefine);</div><div class="line">        [invocation setReturnValue:ret];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="v0-1-5"><a href="#v0-1-5" class="headerlink" title="v0.1.5"></a>v0.1.5</h2><h3 id="版本动态-6"><a href="#版本动态-6" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>增加 performSelectorInOC(sel, args, cb) 接口，在 JSContext 之外执行 OC 方法，避免 JavaScriptCore context lock，能够并发执行 OC 方法</li>
<li>增加 JPLoader</li>
<li>代码优化和问题修复</li>
</ul>
<h4 id="增加-performSelectorInOC-sel-args-cb-接口，在-JSContext-之外执行-OC-方法，避免-JavaScriptCore-context-lock，能够并发执行-OC-方法"><a href="#增加-performSelectorInOC-sel-args-cb-接口，在-JSContext-之外执行-OC-方法，避免-JavaScriptCore-context-lock，能够并发执行-OC-方法" class="headerlink" title="增加 performSelectorInOC(sel, args, cb) 接口，在 JSContext 之外执行 OC 方法，避免 JavaScriptCore context lock，能够并发执行 OC 方法"></a>增加 performSelectorInOC(sel, args, cb) 接口，在 JSContext 之外执行 OC 方法，避免 JavaScriptCore context lock，能够并发执行 OC 方法</h4><p><a href="https://github.com/bang590/JSPatch/commit/6e2ab4f5eb750d364134f2eaac5483373d289972" target="_blank" rel="external">https://github.com/bang590/JSPatch/commit/6e2ab4f5eb750d364134f2eaac5483373d289972</a></p>
<p>实现还是比较简单的，就是在 __c 方法里区分 performSelectorInOC，返回一个配置参数对象，然后真正调用时，传递到 JPforwardInvocation 里识别特殊配置参数，单独执行 callSelector。</p>
<p>另外，想吐槽的是代码提交还是不够规范，没有说明地改动一些东西，单元测试里找不到对应的修改。</p>
<h2 id="v0-2"><a href="#v0-2" class="headerlink" title="v0.2"></a>v0.2</h2><h3 id="版本动态-7"><a href="#版本动态-7" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>增加 addProtocol() 接口</li>
<li>增加对可变参数的支持</li>
<li>修复在父类forwardInvocation被重写时可能引发的bug</li>
<li>增加 JPCleaner() 接口</li>
</ul>
<h2 id="v1-0"><a href="#v1-0" class="headerlink" title="v1.0"></a>v1.0</h2><h3 id="版本动态-8"><a href="#版本动态-8" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>增加在 defineClass 增加属性</li>
<li>增加 JPLocker 和 JPSpecialInit</li>
<li>增加 defineJSClass 方法，支持以 OC 方式定义 JS 方法</li>
</ul>
<h2 id="v1-1"><a href="#v1-1" class="headerlink" title="v1.1"></a>v1.1</h2><h3 id="版本动态-9"><a href="#版本动态-9" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>引入 libffi，支持动态调用 C 函数</li>
</ul>
<h2 id="v1-1-1"><a href="#v1-1-1" class="headerlink" title="v1.1.1"></a>v1.1.1</h2><h3 id="版本动态-10"><a href="#版本动态-10" class="headerlink" title="版本动态"></a>版本动态</h3><ul>
<li>增加 po() 和 bt() 方法，用于 Safari 调试</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="从架构上理解"><a href="#从架构上理解" class="headerlink" title="从架构上理解"></a>从架构上理解</h3><h3 id="从流程上理解"><a href="#从流程上理解" class="headerlink" title="从流程上理解"></a>从流程上理解</h3><h3 id="从-TestCase-上理解"><a href="#从-TestCase-上理解" class="headerlink" title="从 TestCase 上理解"></a>从 TestCase 上理解</h3></div></article></div></main><footer><div class="paginator"><a href="/2016/12/Git 仓库精简记录/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'jiyee';
var disqus_identifier = '2016/12/JSPatch 源码阅读笔记/';
var disqus_title = 'JSPatch 源码阅读笔记';
var disqus_url = 'http://jiyee.io/2016/12/JSPatch 源码阅读笔记/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jiyee.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 - 2017 <a href="http://jiyee.io">Jiyee Sheng</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?ba828c541dc9447a1fbbb5910973873d";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script></body></html>