<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiyee&#39;s I/O</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiyee.io/"/>
  <updated>2016-12-23T01:24:23.000Z</updated>
  <id>http://jiyee.io/</id>
  
  <author>
    <name>Jiyee Sheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WhatPulse键盘按键数据分析</title>
    <link href="http://jiyee.io/2015/03/WhatPulse%20%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://jiyee.io/2015/03/WhatPulse 键盘按键数据分析/</id>
    <published>2015-03-10T16:00:00.000Z</published>
    <updated>2016-12-23T01:24:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>键盘：Filco Ninja（87键）</p>
<p>分析周期：2014-10-11 ~ 2015-03-09 (138天)</p>
<p>总按键次数：2,863,205</p>
<p>平均每天：20,749</p>
<p><img src="/images/what-pulse.png" alt=""></p>
<p><img src="/images/keys-heatmap.png" alt=""></p>
<p>总结看出，Backspace、Space、Enter、Tab 按键高居前列，总体写代码和 Shell 操作相符。 Backspace 数量明显高于其他，说明输入表达的准确性和稳定性不够，内容出现修改的情况突出（就包括现在打这段文字的时候，有意识地意识到自己不停地在按 Backspace ）。当然， Backspace 跟 Escape 之间的比例也没有 rio 说的 10：1 那么悬殊，可能 Shell 老让我等待退出，不停地按 Esc。</p>
<p> Capslock 键换成了 Hyper 键，但是按键次数上明显少于其他 Ctrl、Alt、Shift 键，WhatPulse 不能统计 Command 键，估计按键次数同样不会少，有点可惜。</p>
<p>相比于左侧的功能键，右侧除了 Shift 之外，Alt 和 Ctrl 几乎少有触及，Shift 键得益于 Karabiner ，强制左侧 ASDF 之类的大写字母必须搭配按右侧的 Shift 键，右侧的 Command 键发挥切换输入法的作用，但是按键次数明显也不及其他功能键，可能切回英文输入法已经集成到 Esc 退出 Vim 插入模式造成的。右侧的 Ctrl 键就可怜了，我几乎想不到使用的场景，可惜了。</p>
<p>F1 到 F12 功能键按键频率同样不高，可能跟之前没有做 iOS 开发，缺乏 IDE 调试有关。（F11 和 F12 属于异常数据，Vim 退出插入模式的时候会触发切换输入法的动作，动作的快捷键映射了 Command+Alt+Ctrl+Shift+F11/F12）</p>
<p>数字键 1 到 4 用于输入法选择和 Tab 切换，5 到 9 的使用频率就相对少很多。</p>
<p>总结下来感受是，我的按键频率相对合理，但是仍然有可优化的空间。下一步考虑如何好好开发右侧功能键、F1 到 F12 键，以及 5-9 之间的数字键的习惯使用。</p>
<p>我很满意我的 Ninja 键盘。</p>
<p><img src="/images/filco-ninja-87.jpg" alt=""></p>
<p>相关参考：<br><a href="http://daily.zhihu.com/story/4213946" title="历经 199 天得到的数据，退格使用次数高达 13 万次" target="_blank" rel="external">历经 199 天得到的数据，退格使用次数高达 13 万次</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;键盘：Filco Ninja（87键）&lt;/p&gt;
&lt;p&gt;分析周期：2014-10-11 ~ 2015-03-09 (138天)&lt;/p&gt;
&lt;p&gt;总按键次数：2,863,205&lt;/p&gt;
&lt;p&gt;平均每天：20,749&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/what-pu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NSJSONSerialization</title>
    <link href="http://jiyee.io/2015/03/NSJSONSerialization/"/>
    <id>http://jiyee.io/2015/03/NSJSONSerialization/</id>
    <published>2015-03-09T16:00:00.000Z</published>
    <updated>2016-12-22T09:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NSJSONSerialization，JSON数据解析API"><a href="#NSJSONSerialization，JSON数据解析API" class="headerlink" title="NSJSONSerialization，JSON数据解析API"></a>NSJSONSerialization，JSON数据解析API</h1><hr>
<p>JSON和Foundation objects之间相互转换的API, 支持ARC, iOS 5+</p>
<p>JSON文档的要求：所有的key都是双引号，不能使用单引号或没有引号</p>
<p>object的要求：</p>
<ol>
<li>顶级节点的数据类型必须是 __NSArray__ 或者 __NSDictionary__</li>
<li>所有节点必须是以下实例： __NSString<strong>, </strong>NSNumber<strong>, </strong>NSArray<strong>, </strong>NSDictionary<strong>, or </strong>NSNull__</li>
<li>所有节点的key必须是 __NSString__</li>
<li><strong>Numbers</strong> 不能是 <strong>NaN</strong> 或者 <strong>infinity</strong></li>
</ol>
<p><code>isValidJSONObject:</code>，判断是否可以正确转换</p>
<p><code>JSONObjectWithData:options:error:</code>，A Foundation object from the JSON data in data, or <strong>nil</strong> if an error occurs.<br>JSON 文档的字符编码只能是 UTF 系</p>
<p><code>NSJSONReadingOptions</code> 包含三种类型：</p>
<ul>
<li>NSJSONReadingMutableContainers，返回可变容器，__NSMutableDictionary__ 或 __NSMutableArray__</li>
<li>NSJSONReadingMutableLeaves，叶节点都转成 __NSMutableString__，目前在 iOS 7 上测试不好用，应该是个 bug，参见：- <a href="http://stackoverflow.com/questions/19345864/nsjsonreadingmutableleaves-option-is-not-working%20" target="_blank" rel="external">http://stackoverflow.com/questions/19345864/nsjsonreadingmutableleaves-option-is-not-working </a></li>
<li>NSJSONReadingAllowFragments，允许顶层节点不是 __NSArray__ 或者 __NSDictionary__，但必须是有效的 JSON Fragment，如解析 <code>@&quot;123&quot;</code> 这样的字符串。<blockquote>
<p>That’s because 32 is a valid JSON fragment (a number), but abcd is not a valid JSON fragment since all strings must be quoted.<br><code>NSString *num=@&quot;32&quot;;</code><br><code>NSString *num=@&quot;\&quot;abcd\&quot;&quot;;</code></p>
</blockquote>
</li>
</ul>
<p><code>JSONObjectWithStream:options:error:</code>，通过数据流解析<br>__NSInputStream__ 数据流必须是可被打开和配置。</p>
<p><code>dataWithJSONObject:options:error:</code>，创建 JSON data<br>如果对象不能正确生成 JSON data，将抛出一个 programming error，并非 internal error，This exception is thrown prior to parsing and represents a programming error。</p>
<p>而 API 里设定的 __error__，If an internal error occurs, upon return contains an NSError object that describes the problem.</p>
<p>所以，在生成 JSON data 之前，需要检查是否能够正确 <code>isValidJSONObject:</code></p>
<p><code>NSJSONWritingOptions</code>，</p>
<ul>
<li>NSJSONWritingPrettyPrinted，指定输出 JSON data 是否执行 pretty print.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NSJSONSerialization，JSON数据解析API&quot;&gt;&lt;a href=&quot;#NSJSONSerialization，JSON数据解析API&quot; class=&quot;headerlink&quot; title=&quot;NSJSONSerialization，JSON数据解析AP
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为 ASUS-AC68U-Merlin 固件交叉编译 shadowsocks-libev</title>
    <link href="http://jiyee.io/2015/01/%E4%B8%BA%20ASUS-AC68U-Merlin%20%E5%9B%BA%E4%BB%B6%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%20shadowsocks-libev/"/>
    <id>http://jiyee.io/2015/01/为 ASUS-AC68U-Merlin 固件交叉编译 shadowsocks-libev/</id>
    <published>2015-01-23T16:00:00.000Z</published>
    <updated>2016-12-23T01:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>开篇向 <a href="https://github.com/RMerl/asuswrt-merlin" title="ASUS-AC68U-Merlin Firewarm" target="_blank" rel="external">Merlin固件</a>及<a href="https://github.com/RMerl/asuswrt-merlin/wiki" title="Merlin Firewarm Wiki" target="_blank" rel="external">Wiki</a> 致敬，向 tengattack 写下的 《<a href="https://bless.moe/blog/po/1027" title="为R6300v2新固件交叉编译shadowsocks-libev" target="_blank" rel="external">为R6300v2新固件交叉编译shadowsocks-libev</a>》 一文致敬。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文基本参照了以上两篇文章，经过两个漫漫长夜，终于鼓捣出能够在 ASUS-AC68U Merlin 固件上运行的 shadowsocks-libev。</p>
<p>上周刚买了华硕 AC68U 路由器，看中的就是强大的配置和能够足够鼓捣的空间。但是，本人是个前端开发工程师，目前正在朝 iOS 开发工程师转行，对于怎么样编译固件，编译固件应用，甚是无知。</p>
<p>什么交叉编译，ARM 平台，编译器，基本库等等内容，基本处于很无知的阶段，虽然也用 Mac 和 Linux 平台，但是对于 C/C++ 环境里的一切了解甚少。</p>
<h2 id="曲折的过程"><a href="#曲折的过程" class="headerlink" title="曲折的过程"></a>曲折的过程</h2><p>好吧，那既然闪闪亮的路由器已经到家了，翻越长城的欲望怒不可止。心想一定要搞到一个能够运行在路由器上的 Shadowsocks。一路 Google，发现根本没有人做过这件事，基本没可能直接拿现成的，看来只能自己编译了。之前看到了 Merlin 源代码里有一个<a href="https://github.com/RMerl/asuswrt-merlin/blob/master/README.TXT" target="_blank" rel="external">README.TXT</a>，有写怎么样配置编译环境和怎么编译固件，但是后来发现这个文档是基于 MIPS 平台，而 AC68U 却是 ARM 平台，文档过时了。。。另外，找到 Merlin 固件也能够支持 <a href="https://github.com/RMerl/asuswrt-merlin/wiki/Entware" target="_blank" rel="external">Entware</a>，但是却又说：</p>
<blockquote>
<p>Note that Entware is only available on the MIPS-based routers. This means the RT-AC56U and RT-AC68U are not supported.</p>
</blockquote>
<p>好吧，那继续 Google 和翻论坛帖子，国内恩山论坛上搜索 AC68U 帖子数还很少，国外 <a href="http://forums.smallnetbuilder.com" target="_blank" rel="external">smallnetbuild</a> 上也不多，估计是 AC68U 的用户基数比较少，而愿意折腾的同学会选择性价比更高的其他型号。</p>
<p>最后，不知道哪儿看到 <a href="http://wiki.openwrt.org/doc/devel/crosscompile" target="_blank" rel="external">一篇文章</a> 说 OpenWRT 固件里可以把需要编译的应用放到 packages 里，能就基本 SDK 编译了。虽然这段话到现在还不知道怎么理解，但至少提供了一个思路，那就是先编译一个编译 Merlin 固件看看。</p>
<p>编译固件需要编译平台，看 Merlin 作者推荐 Ubuntu，我就用 Vagrant 搭建了 Ubuntu 环境，下载了 Ubuntu 14.04 64bit 的 box（64bit还是给后面工作埋下了坑），成功加载运行，链接本地 <code>/Users/jiyee/Vagrant</code> 目录到虚拟机的 <code>/vagrant</code> 目录。Merlin 固件源代码之前已经 clone（好大，有4Gb），就放在 <code>/Users/jiyee/Vagrant</code> 目录。这一步走的比较顺利。</p>
<p>然后，按照 <a href="https://github.com/RMerl/asuswrt-merlin/wiki/Compile-Firmware-from-source-using-Ubuntu" target="_blank" rel="external">Merlin Wiki</a> 里的配置编译环境的步骤，一步步设置，通过 apt-get 安装一堆编译工具，配置 <code>$PATH</code> ，最后执行 <code>make rt-ac68u</code> 。看 <a href="http://see.sl088.com/wiki/%E7%BC%96%E8%AF%91Openwrt%E5%9B%BA%E4%BB%B6" target="_blank" rel="external">一篇文章</a> 说固件编译很慢，就合上电脑睡觉了。第二天醒来一看，有报错，很正常，”编译固件有报错很正常”，心想。但是，错误提示一大堆，基本也看不懂。想到论坛上问问作者，后来一想环境不一样，估计问了也白问，还得注册论坛，写一篇英文帖子去描述，粘贴一堆编译信息，想想就累，遂放弃了。不过，至少我配置好了编译环境，小开心。退一步说，即便能够编译出固件我也不知道下一步该怎么办。</p>
<p>这一下打击让我歇了两天，两天之后再次兴起想到这件事，翻出原来 Google 来的那些博客文档，看到了 tengattack 写的 《<a href="https://bless.moe/blog/po/1027" title="为R6300v2新固件交叉编译shadowsocks-libev" target="_blank" rel="external">为R6300v2新固件交叉编译shadowsocks-libev</a>》 一文，虽然这篇文章之前也草草看过，没看明白，所以决定这次认真看看。</p>
<p>在配置环境的过程中，我了解到了 <a href="http://www.uclibc.org/" target="_blank" rel="external">uclibc</a> 编译环境，它是嵌入式平台的编译库，看到这篇文章花很大力气从 uclibc 编译环境迁移到 musl。google 到 <a href="http://www.musl-libc.org/" target="_blank" rel="external">musl</a>，看到主页上有一个链接 <a href="http://www.etalabs.net/compare_libcs.html" target="_blank" rel="external">《See how musl compares to other major libcs.》</a> ，一眼就看到了 glibc，那不是 GNU 的 C Library 么（我还是知道一点的），推测 uclibc，musl，glibc 都是一回事，只是 C Library 在不同平台上的实现或是同一平台上的不同实现。心想，我都不用 uclibc 迁移到 musl，因为 Merlin 固件就是在 uclibc 环境下编译的，省事。</p>
<p>作者也没提编译固件的事，直接上来就编译程序了，看来有点眉目了。</p>
<p>那好吧，我明白了交叉编译的最基本概念，就是在一个平台编译另一个平台能运行的程序。就写了一个最基本的C代码，<code>hello.c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行 <code>gcc hello.c -o hello</code> ，编程成功，运行 <code>./hello</code> ，成功打出了 <code>Hello World!</code>。这是 C 语言学习的第一步，而我却拿来验证了编译器是否能成功执行。</p>
<p>然后运行 <code>arm-uclibc-linux-2.6.36-gcc hello.c -o hello</code> ，报错，傻眼。</p>
<blockquote>
<p>/opt/brcm-arm/bin/../libexec/gcc/arm-brcm-linux-uclibcgnueabi/4.5.3/cc1: error while loading shared libraries: libmpc.so.2: cannot open shared object file: No such file or directory</p>
</blockquote>
<p>Google 一番之后，说有让执行 <code>ldd /opt/brcm-arm/libexec/gcc/arm-brcm-linux-uclibcgnueabi/4.5.3/cc1</code> 看看动态链接库是否完整，一看果然有 Not Found。</p>
<blockquote>
<p>   linux-gate.so.1 =>  (0xf77bf000)<br>   libmpc.so.2 => not found<br>   libmpfr.so.4 => not found<br>   libgmp.so.10 => not found<br>   libdl.so.2 => /lib/i386-linux-gnu/libdl.so.2 (0xf77aa000)<br>   libelf.so.1 => /usr/lib/i386-linux-gnu/libelf.so.1 (0xf7792000)<br>   libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf75e3000)<br>   /lib/ld-linux.so.2 (0xf77c0000)</p>
</blockquote>
<p>有三个 so 包没有能链接，在 <code>/usr/lib/i386-linux-gnu/</code> 目录里果然没有 <code>libmpc.so.2</code> 等文件。再一番 Google，意思是 <a href="http://unix.stackexchange.com/questions/119798/mint-correct-way-to-install-lib-i386-linux-gnu-libgmp-so-3" target="_blank" rel="external">装个32位链接库看看</a>，执行 <code>apt-get install ia32-libs</code>，安装错误。。。漫漫过程中一个库网络链接好像失效了，安装失败。这个时候在 StackOverflow 上看到了 <a href="http://stackoverflow.com/questions/19625451/cc1-error-while-loading-shared-libraries-libmpc-so-2-cannot-open-shared-objec" target="_blank" rel="external">一个帖子</a> 说，是否正确设置了 <strong>LD_LIBRARY_PATH</strong> 环境变量。心想，Merlin 固件的 Wiki 里没有提到呀，什么东西呀，那先 <code>echo $LD_LIBRARY_PATH</code> 看看，一 echo 为空，再在 <code>/opt/brcm-arm</code> 目录里找找，也有一个 <code>lib</code> 目录，里面就有那些缺失的文件。那就设置 <code>export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/opt/brcm-arm/lib:/usr/local/lib:/usr/lib</code>。再执行 <code>ldd /opt/brcm-arm/libexec/gcc/arm-brcm-linux-uclibcgnueabi/4.5.3/cc1</code>，内容发生了变化，都能找到了。</p>
<blockquote>
<p>   linux-gate.so.1 =>  (0xf76f4000)<br>   libmpc.so.2 => /opt/brcm-arm/lib/libmpc.so.2 (0xf76de000)<br>   libmpfr.so.4 => /opt/brcm-arm/lib/libmpfr.so.4 (0xf768e000)<br>   libgmp.so.10 => /opt/brcm-arm/lib/libgmp.so.10 (0xf7631000)<br>   libdl.so.2 => /lib/i386-linux-gnu/libdl.so.2 (0xf7620000)<br>   libelf.so.1 => /usr/lib/i386-linux-gnu/libelf.so.1 (0xf7608000)<br>   libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7459000)<br>   libm.so.6 => /lib/i386-linux-gnu/libm.so.6 (0xf7412000)<br>   /lib/ld-linux.so.2 (0xf76f5000)</p>
</blockquote>
<p>再次执行 <code>arm-uclibc-linux-2.6.36-gcc hello.c -o hello</code>，编译成功，执行 <code>./hello</code>，报错</p>
<blockquote>
<p>bash: ./hello: cannot execute binary file: Exec format error</p>
</blockquote>
<p>欣喜，貌似成功了。那把编译出来的 hello 文件 scp 到路由器上再执行，成功打印了 <code>Hello World!</code>，哇哦，看来离成功不远了。</p>
<p>因为 Merlin 固件自带里 OpenSSL，省下一大把精力。</p>
<p>再看了一遍那篇文章，照猫画虎的写下了以下编译命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CC=arm-uclibc-linux-2.6.36-gcc CXX=arm-uclibc-linux-2.6.36-g++ AR=arm-uclibc-linux-2.6.36-ar RANLIB=arm-uclibc-linux-2.6.36-ranlib ./configure --prefix=/vargrant/shadowsocks-libev --host=arm-uclibc-linux</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p><code>/vargrant/shadowsocks-libev/src</code> 目录下出现了4个可执行文件。成功了。。。我哭啊，赶紧再 scp 到路由器，执行 <code>./ss-local -s server_ip -p 8080 -l 7070 -k password -v -m aes-256-cfb</code>，又成功了。。。在本地配置 SOCKS5 代理，嗖嗖地翻出了万里长城。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>哇哈哈，洋洋洒洒写了这么多，虽然实质内容没多少，也基本都是别人的，但是对于一个不懂交叉编译甚至是编译原理的同学来说成功能够搞定这一切，还是很值得欣慰的。我把其中经历的每一步都详实地写下来，把其中参考过的文档都附上链接地址，只是希望能够给像我这样的同学作一点参考，在茫茫 Google 搜索结果里找到一点点希望。</p>
<p>其实，很多文章在第一次 Google 的时候会被忽略，写太多了，看不懂。第二次 Google 的时候会被扫过，挑重点看看。第n次 Google 的会被关注，醍醐灌顶，深深受益。因为你每一次都站上了不同的高度，直到你够到了作者的高度。最后，当你自己想写下什么的时候，他们会被感谢，因为没有他们，你就无法完成这一切。</p>
<p>最后，为了 Google，感谢 Google。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开篇向 &lt;a href=&quot;https://github.com/RMerl/asuswrt-merlin&quot; title=&quot;ASUS-AC68U-Merlin Firewarm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Merlin固件&lt;/a&gt;及&lt;a h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2014 Hybrid开发风潮 - 2014 iWeb峰会参会感</title>
    <link href="http://jiyee.io/2014/08/2014%20Hybrid%E5%BC%80%E5%8F%91%E9%A3%8E%E6%BD%AE%20-%202014%20iWeb%E5%B3%B0%E4%BC%9A%E5%8F%82%E4%BC%9A%E6%84%9F/"/>
    <id>http://jiyee.io/2014/08/2014 Hybrid开发风潮 - 2014 iWeb峰会参会感/</id>
    <published>2014-08-18T16:00:00.000Z</published>
    <updated>2016-12-22T09:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周末参加了 2014 年度的 iWeb 峰会，那叫一个人山人海啊。不过跟前几年有点不一样的是，今年似乎正刮一阵 Hybrid 开发风，主会场和工具专场连着介绍了三款不同的 Hybrid 开发框架，<a href="https://github.com/dcloudio" target="_blank" rel="external">Native.js</a>，<a href="http://www.appcan.cn" target="_blank" rel="external">AppCan</a>，<a href="https://software.intel.com/en-us/html5/tools" target="_blank" rel="external">Intel XDK</a>，各自有不同的思路和实现，给 Web 开发者们提供了不同的 App 开发平台和能力，那就一个个分别说说。</p>
<h3 id="Native-js"><a href="#Native-js" class="headerlink" title="Native.js"></a>Native.js</h3><p>实质上属于 <a href="http://www.html5plus.org/" target="_blank" rel="external">HTML5+</a> 规范和 HBuilder 的结合实现， HTML5+ 就没什么好说的，据说是国内组织搞的（不太清楚，感觉就是 DCloud 牵头搞的），应用上跟 PhoneGap 类似。 Native.js 属于 HTML5+ 规范未实现的原生 API 部分的 Proxy ，是不是可以理解为那些规范里的实现都是通过 Native.js 实现的，就是暴露了原生 API 封装实现给了开发者，看难度好像有点大，需要根据不同平台调用原生 API 。那就要求开发者理解那些原生 API ，思路上跟 Titanium 的 Widget 类似，但是实现上选择了 JS Bridge 方式，我认为不是很好的一个方向，有点噱头的意思。那在它的平台上就只能希望 HTML5+ 规范的部分能实现的更加完整和全面。</p>
<p>关于 Native.js 的实现，我的猜测是大量的使用了反射来将 JS 转为 Java 或者 Objective-C ，性能上是很大的考验。</p>
<p>另外， HBuilder 是基于 Aptana 开发的，更加倾向于小清新，会场上也真的已经有了不少实际用户，让我大吃一惊。</p>
<p>关于 HBuilder 的介绍参看：<a href="http://www.csdn.net/article/2014-04-11/2819266-jinjiang-with-hbuilder" target="_blank" rel="external">《近匠》HBuilder：如何用JS调用几十万原生API？</a></p>
<p>Dcloud.io 官网上有关于 Native.js 的<a href="http://download.dcloud.net.cn/HTML5+%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-Native.js.pdf" target="_blank" rel="external">PDF文档</a></p>
<h3 id="AppCan"><a href="#AppCan" class="headerlink" title="AppCan"></a>AppCan</h3><p>国内比较成熟的 Hybrid 开发平台，开发框架涵盖了丰富的自定义 API ，商业模式也比较清晰，但是，相对来说比较封闭，更加适合政府部门，我猜的。</p>
<p>具体的就不予置评了，请参看<a href="http://www.appcan.cn" target="_blank" rel="external">AppCan官网</a></p>
<h3 id="Intel-XDK"><a href="#Intel-XDK" class="headerlink" title="Intel XDK"></a>Intel XDK</h3><p>Intel XDK 框架真是第一次听说，之前孤陋寡闻了。 Intel 居然也加入了 Hybrid 开发阵营，可能真的是像他们的老大张海立所说的这款产品之前一直是国外团队在开发，国外团队也刚开始接手不久。</p>
<p>张海立的演讲很精彩，搜了一下，复旦毕业，言语真的很像上海人，还真有点想投奔他的感觉，哈哈。</p>
<p>至于 Intel XDK 这款产品，那就是站在开源产品之上集大成，相较于前两位更加开放、新潮，集成了包括<a href="http://cordova.apache.org" target="_blank" rel="external">Cordova</a>，<a href="http://ripple.incubator.apache.org" target="_blank" rel="external">Ripple</a>，<a href="http://brackets.io" target="_blank" rel="external">Brackets</a>， V8 ，还有一些开源的 UI 框架和开放的 Service 服务，将设计、开发、测试、编译、分发集成设计出一套完整的开发方案， IDE 级别。</p>
<p>出彩的 <a href="https://crosswalk-project.org" target="_blank" rel="external">Crosswalk</a>，看了下官网介绍，似乎是 Cordova 升级版，以至于每次出现 XDK 必出现 Crosswalk ，躲都躲不过。</p>
<p><a href="http://slides.com/zhanghaili/intelxdk#/" target="_blank" rel="external">XDK Slide</a>，瞧人家多潮，都用上 slides 了。。。</p>
<p><img src="/images/iweb.jpg" alt="iWeb 峰会主会场"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周末参加了 2014 年度的 iWeb 峰会，那叫一个人山人海啊。不过跟前几年有点不一样的是，今年似乎正刮一阵 Hybrid 开发风，主会场和工具专场连着介绍了三款不同的 Hybrid 开发框架，&lt;a href=&quot;https://github.com/dcloudio&quot; 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[转]HTML5、Web引擎与跨平台移动App开发</title>
    <link href="http://jiyee.io/2014/08/HTML5%E3%80%81Web%E5%BC%95%E6%93%8E%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E5%8A%A8App%E5%BC%80%E5%8F%91/"/>
    <id>http://jiyee.io/2014/08/HTML5、Web引擎与跨平台移动App开发/</id>
    <published>2014-08-18T16:00:00.000Z</published>
    <updated>2016-12-22T10:00:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>移动端跨平台应用开发是个有趣的话题。纵观该领域目前各个开发商提供的多种方案，大致可以分为三大类：</p>
<ol>
<li><p>基于HTML5的方案。该方案以PhoneGap/Cordova为代表。其基本思路是针对HTML5标准目前功能上的不足，补充定义了一套比较实用的API（比如硬件访问/系统交互等），然后基于平台上自带的Web引擎（比如iOS的UIWebview等），通过扩展机制实现了这些API，在此基础上再提供一套应用打包部署系统。Intel的XDK也属于此类方案。</p>
</li>
<li><p>将Native API映射封装成统一语言的API的方案。该方案以Titanium、Xamarin为代表，其中Titanium提供JavaScript API，Xamarin提供C# API。这样的好处是可以较容易达到和Native API类似的能力，编程模型/方式也和原生应用相似。</p>
</li>
<li><p>有行业针对性的HTML5 API方案。比如Ludei的CocoonJS就是一个比较有意思的方案，它设计了一套专门针对2D/3D游戏开发的API（支持iOS和Android）。可以认为它是HTML5图形操作的子集（Canvas +WebGL），再加上一些扩展的API比如硬件访问能力/广告/应用内购买/社交网络整合等，以实现一个完整的游戏引擎。</p>
</li>
</ol>
<p>本文重点介绍基于HTML5的方案相比其他方案的优缺点，如何实现更好的效果，以及目前的一些进展。</p>
<h3 id="HTML5方案的特点"><a href="#HTML5方案的特点" class="headerlink" title="HTML5方案的特点"></a>HTML5方案的特点</h3><p>原生API映射的方案，如Titanium、Xamarin，其优点在于功能和性能与原生系统比较接近。但是，由于不同系统原生API设计上还是会有不少差异，API的映射还是需要不少的权衡取舍。同时，由于这些API是这些厂商自定义的，谈不上什么标准，相应的开发资源（程序库/技术支持/社区等等）也相对有限。</p>
<p>而另一方面，标准化、开发资源的丰富则是HTML5方案最大的优点，同时第三方的HTML5框架工具比如PhoneGap/Cordova也极大促进了HTML5应用的发展，它们提供了方便的跨平台应用打包/发布服务、实用的API、灵活的扩展机制、以及积累下来的丰富的第三方API实现。而上游的W3C一旦开始支持一些新的API，PhoneGap/Cordova也可以很快沿用这些标准的API将相关能力开放出去。</p>
<p>HTML5方案的主要不足则在于功能和性能方面，这主要是因为HTML5应用的能力严重依赖于系统自带的Web引擎：iOS的UIWebview、Android的Webview等，此类组件的HTML5能力相比Safari for iOS、Chrome for Android都要差一截。另外在Android平台上，由于系统碎片化比较严重，不同Android版本的Webview的HTML5能力也有较大差异，导致相应的HTML5应用一致性难以保证。</p>
<p>好消息是，现在已经出现一些第三方的Web引擎以提供比系统默认的Webview更好的功能和性能，而PhoneGap/Cordova也正在改进架构以便引入这些更好的第三方Web引擎。另外对于Tizen、Firefox OS这样本身就是HTML5 Runtime加上扩展API的系统而言，HTML5应用是一等公民，在功能拓展方面相比iOS、Android上会增强不少。</p>
<p>而第三种方案，CocoonJS的优点是专注于2D/3D游戏开发，画图性能很好，比如同时画1000个精灵也能达到60FPS，这是绝大多数的浏览器/通用的HTML5引擎目前还做不到的。这个方案的缺点在于，由于它的画图操作简化了很多路经，它无法做到和HTML5 DOM元素的互操作，而且它的HTML5能力也只是一个子集，功能比较受限。目前CocoonJS针对Android也引入了另外一种模式Webview+作为补充，Webview+基于Chromium的内核加上Cordova API的支持以实现更通用的HTML5能力。</p>
<p>总的来说，HTML5应用的能力很大程度上依赖于Web引擎的能力。因此，无论是移动操作系统开发商还是开发工具的开发商，都持续在Web引擎的方向投入了更多的努力。</p>
<h3 id="Web引擎"><a href="#Web引擎" class="headerlink" title="Web引擎"></a>Web引擎</h3><p>Web引擎目前大致可分为三种方式：</p>
<ol>
<li>浏览器，比如Safari/Chrome/UC Browser等;</li>
<li>系统自带的Webview组件，比如上面提到的iOS UIWebview和Android Webview</li>
<li>专门的Web Engine，比如Intel的开源项目Crosswalk、Ludei的Webview+</li>
</ol>
<p>浏览器方式很容易理解，一个HTML5应用就是一个Web页面，用户通过浏览器打开一个URL，然后进入浏览器的全屏模式/App模式进行操作，或者是通过点击一个事先创建好的快捷方式打开应用。这种方式的性能取决于浏览器本身对HTML5的支持情况，一般来说要优于Webview组件的方式，但是问题在于不同的浏览器有差异，而且通过浏览器运行HTML5较难做到类似原生应用的体验（应用切换/权限管理/系统资源访问/整合等）以及丰富的API支持。</p>
<p>Webview组件方式的一般用法是以Hybrid的方式发布HTML5应用，即上述提到的PhoneGap/Cordova方案所采用的方式。其问题已经在上面提到过，主要是Webview组件本身对HTML5的支持能力不足。</p>
<p>专门的Web引擎可以有较好的HTML5功能和性能支持，同时有较好一致性，类似原生应用的系统整合也可以做得较好。这种方式的缺点则在于开发者需要将Web引擎与应用程序一起打包，生成的应用大小会更大，因此有的Web引擎（如Crosswalk）也提供了一种“共享模式”，让多个应用可以共享一个Web引擎，仅当应用第一次启动并且发现系统还没有相应Web引擎时才提示用户下载安装。</p>
<p>目前的发展趋势是：通过PhoneGap/Cordova方式得到丰富的API支持，通过专门开发的Web引擎去提升HTML5的能力。</p>
<p>Crosswalk和Ludei的Webview+在概念上比较类似。Webview+是闭源的，目前还不好评估；Crosswalk由我所在的团队开发，是开源的（BSD许可协议），基于Chromium内核，着重于对HTML5功能和性能的支持，发布周期为六周一次，支持Cordova API。</p>
<p>目前Crosswalk正式支持的移动操作系统包括Android和Tizen，在Android 4.0及以上的系统中使用Crosswalk的Web应用程序体验和原生应用没有区别。该引擎现在已经成为众多知名HTML5平台和应用的推荐引擎，包括Google Mobile Chrome App、Intel XDK、Famo.us和Construct2等等，未来的Cordova 4.0也计划集成该Web引擎。不过比较遗憾的是，由于iOS的限制（iOS不允许应用使用使用除iOS UIWebView之外第三方的JIT–即时编译引擎），目前Crosswalk也没有办法提供直接的支持，但这也许会随着HTML5更广泛的进入移动市场而发生改变。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在的HTML5 App（加上API扩展）已经可以胜任很多事了，比如教育类应用，休闲游戏等等。不过对于那些实时性要求比较高的、计算量大的（比如涉及大量的元素绘制，或并行计算等）、复杂的3D游戏，多人在线游戏/应用等还有不少差距。另外，工具方面，如何能够更高效的调试/开发/性能内存调优 HTML5应用也是另外一个需要提高的地方。不过，这些方面也在不断的演进。相信不久的将来，HTML5终会成为主流移动开发平台。</p>
<h3 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h3><p>余枝强目前是英特尔开源技术中心的软件技术经理。 主要负责HTML5 引擎 – Crosswalk 在安卓平台的开发，以及一些其他和Web有关的新兴技术的研发工作（如HTML5 并行技术, 3D Camera等）。他坚信Web是未来， 也非常希望和大家一起努力，让这个未来能够更快更好的到来。</p>
<p>本文转自<a href="http://www.infoq.com/cn/articles/html5-crosswalk" target="_blank" rel="external">http://www.infoq.com/cn/articles/html5-crosswalk</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端跨平台应用开发是个有趣的话题。纵观该领域目前各个开发商提供的多种方案，大致可以分为三大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于HTML5的方案。该方案以PhoneGap/Cordova为代表。其基本思路是针对HTML5标准目前功能上的不足，补充定义了一套比较实用的A
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Appecelerator Titanium开发经验谈之三 - 那些Ti&amp;TiShadow坑</title>
    <link href="http://jiyee.io/2014/08/Appecelerator%20Titanium%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E8%B0%88%E4%B9%8B%E4%B8%89%20-%20%E9%82%A3%E4%BA%9BTi&amp;TiShadow%E5%9D%91/"/>
    <id>http://jiyee.io/2014/08/Appecelerator Titanium开发经验谈之三 - 那些Ti&amp;TiShadow坑/</id>
    <published>2014-08-11T16:00:00.000Z</published>
    <updated>2016-12-22T09:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>图片素材放在 app/assets/images/ 目录，但是在引用的时候 TiShadow 环境里可以直接写 pic.png，但是在 Android 编译环境下就得写成 /images/pic.png</p>
</li>
<li><p>lib 放在 app/assets/lib/ 目录</p>
</li>
<li><p>TiShadow 环境里 CommonJS 写法可以写成 <code>exports = {methodName: methodName}</code>，但是在 Android 编译环境下就得写成 <code>exports.methodName = methodName</code></p>
</li>
</ul>
<p><strong>PS：</strong> 上述坑还是吃了不了解 Android 编译过程和 TiShadow 运行时环境的亏，看来即便搞 Hybrid App 开发，不懂 Native App 开发原理，还是搞不定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;图片素材放在 app/assets/images/ 目录，但是在引用的时候 TiShadow 环境里可以直接写 pic.png，但是在 Android 编译环境下就得写成 /images/pic.png&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lib 放在 ap
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac App 盗版软件干掉计划</title>
    <link href="http://jiyee.io/2014/08/Mac%20App%E7%9B%97%E7%89%88%E8%BD%AF%E4%BB%B6%E5%B9%B2%E6%8E%89%E8%AE%A1%E5%88%92/"/>
    <id>http://jiyee.io/2014/08/Mac App盗版软件干掉计划/</id>
    <published>2014-08-11T16:00:00.000Z</published>
    <updated>2016-12-22T09:49:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个 Macer，记得很久以前看到伞哥说过他把他 Mac 上所有的软件都正版化了。</p>
<p>那么，现在既然经济上还能支持，那就开始我的正版化之旅，支持一下同行。</p>
<p>希望今年之内把所有软件都正版化，尽量替换掉那些暂时买不起的。</p>
<p>PS:</p>
<p>好了，2014年年末，软件正版化道路基本告一段落，想买的能买的基本都已经入了，可以更愉快的玩耍了。</p>
<p><strong>想要软件列表：</strong></p>
<ul>
<li>OmniGraffle</li>
</ul>
<p>==========================</p>
<p><strong>已购软件列表： </strong>(注：<del>software</del>，已经购买正版或免费版)</p>
<ul>
<li><del>Tower</del></li>
<li><del>DwellClick</del></li>
<li><del>Inboard</del></li>
<li><del>Reveal</del></li>
<li><del>Charles</del></li>
<li><del>MindNode Pro</del></li>
<li><del>FlowVella</del></li>
<li><del>LiveReload</del></li>
<li><del>TotalPath</del></li>
<li><del>SnapNDrag Pro</del></li>
<li><del>MacID</del></li>
<li><del>DwellClick</del></li>
<li><del>iTranslate</del></li>
<li><del>Byword</del></li>
<li><del>Spillo</del></li>
<li><del>Sublime Text</del></li>
<li><del>AppCode</del></li>
<li><del>PyCharm</del></li>
<li><del>Sketch</del></li>
<li><del>Framer Studio</del></li>
<li>Microsoft Office, <del>NeoOffice</del>, <del>iWork</del>, <del>LibreOffice</del></li>
<li><del>Beyond Compare 4</del></li>
<li><del>CodeRunner</del></li>
<li><del>RapidSVN</del>, <del>SmartGit</del></li>
<li><del>Hazel</del></li>
<li><del>Little Snitch</del></li>
<li><del>Keyboard Maestro</del></li>
<li><del>1Keyboard</del></li>
<li><del>Charles</del>, <del>Cellist</del></li>
<li><del>Boom 2</del></li>
<li><del>Contexts</del></li>
<li><del>TotalSpace2</del></li>
<li>OmniGraffle，<del>XMind</del></li>
<li>Navicat Premium，<del>Squuel Pro</del>, <del>Datum</del></li>
<li><del>Paw</del>，<del>CocoaRestClient</del></li>
<li><del>VMware Fusion</del></li>
<li><del>Movist</del></li>
<li><del>aText</del></li>
<li><del>Elite Keylogger Pro</del></li>
<li><del>Day One</del></li>
<li><del>Alfred 2</del></li>
<li>Adobe Photoshop CC, <del>pixelmator</del></li>
<li><del>CleanMyMac 2</del></li>
<li><del>Bartender</del></li>
<li><del>Intellij IDEA CE</del>, <del>Android Studio</del></li>
<li><del>Dash</del></li>
<li><del>iTerm2</del></li>
<li><del>1Password</del></li>
<li><del>Yep</del></li>
<li><del>SSH Tunnel</del></li>
<li><del>ForkLift</del>, <del>Path Finder 7</del></li>
<li><del>PopClip</del></li>
<li><del>Xee3</del>, <del>LilyView</del></li>
<li><del>Manico</del></li>
<li><del>Moom</del></li>
<li><del>Ulysses</del></li>
<li><del>Scrivener</del></li>
<li><del>Todoist</del>, <del>Clear</del>, <del>OmniFocus 2</del></li>
<li><del>Vitamin-R 2</del></li>
<li><del>Fantastical</del></li>
<li><del>Leaf</del>, <del>ReadKit</del></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个 Macer，记得很久以前看到伞哥说过他把他 Mac 上所有的软件都正版化了。&lt;/p&gt;
&lt;p&gt;那么，现在既然经济上还能支持，那就开始我的正版化之旅，支持一下同行。&lt;/p&gt;
&lt;p&gt;希望今年之内把所有软件都正版化，尽量替换掉那些暂时买不起的。&lt;/p&gt;
&lt;p&gt;PS:&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Appecelerator Titanium开发经验谈之二 - Ti、TiShadow、Genymotion环境搭建</title>
    <link href="http://jiyee.io/2014/08/Appecelerator%20Titanium%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E8%B0%88%E4%B9%8B%E4%BA%8C%20-%20Ti%E3%80%81TiShadow%E3%80%81Genymotion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://jiyee.io/2014/08/Appecelerator Titanium开发经验谈之二 - Ti、TiShadow、Genymotion环境搭建/</id>
    <published>2014-08-10T16:00:00.000Z</published>
    <updated>2016-12-22T09:48:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，不得不说最近一年，Ti 的文档得到了明显地提升，只要认真看一遍文档，基本的流程</p>
<p>Titanium 环境搭建还是比较简单的，基本都能在 <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Quick\_Start" target="_blank" rel="external">http://docs.appcelerator.com/titanium/latest/#!/guide/Quick\_Start</a> 找到。</p>
<ul>
<li>安装 Java，Node 环境</li>
<li>安装 Android platform SDKs，以及对应版本的 Android SDK</li>
<li>安装 Titanium SDK，目前是 3.3.0</li>
<li>安装 Titanium CLI 和 Allow CLI</li>
<li>安装 Titanium Studio</li>
</ul>
<p>这样就完成了基本的 Android Titanium 开发环境。</p>
<p>另外，Android 虚拟机的话，强烈推荐使用 <a href="http://www.genymotion.com/" target="_blank" rel="external">Genymotion</a>，比默认的快很多，而且很容易多版本部署和升级。</p>
<p>如果想快速开发的话，那最好装上 <a href="http://tishadow.yydigital.com/" target="_blank" rel="external">TiShadow</a>，类似的还有 <a href="https://github.com/appersonlabs/RapidDev" target="_blank" rel="external">RapidDev</a>，他是在 Ti SDK 之上，再封装了一层 runtime，将本地的 Titanium+Alloy 代码进行动态编译，并在 TiShadow 运行时上进行替换更新，实现 LiveView 效果。</p>
<p>不过在 Genymotion 上运行 TiShadow 还需要安装对应 Android 版本的 gapps。</p>
<p>其他好像就没有什么了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，不得不说最近一年，Ti 的文档得到了明显地提升，只要认真看一遍文档，基本的流程&lt;/p&gt;
&lt;p&gt;Titanium 环境搭建还是比较简单的，基本都能在 &lt;a href=&quot;http://docs.appcelerator.com/titanium/latest/#!/gui
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Appecelerator Titanium开发经验谈之一 - PhoneGap与Titanium的艰难选择</title>
    <link href="http://jiyee.io/2014/08/Appecelerator%20Titanium%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E8%B0%88%E4%B9%8B%E4%B8%80%20-%20PhoneGap%E4%B8%8ETitanium%E7%9A%84%E8%89%B0%E9%9A%BE%E9%80%89%E6%8B%A9/"/>
    <id>http://jiyee.io/2014/08/Appecelerator Titanium开发经验谈之一 - PhoneGap与Titanium的艰难选择/</id>
    <published>2014-08-04T16:00:00.000Z</published>
    <updated>2016-12-22T09:54:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>跟 PhoneGap、AppCan 类似，Appecelerator Titanium（简称<strong>Ti</strong>）致力于使用 JavaScript 去快速构建 App ([Atwood定律]在发功)。它们有效地抚平了学习曲线，使得 App 开发不再依赖于对 Objective-C 或 Java 语言以及相应开发框架，转而建立在 JavaScript、V8 和 Node 基础之上，让我等前端工程师在 App 开发大潮中有机会去施展。</p>
<p>好像在中文社区谈论 PhoneGap 的相对多一些，至少搜索相关的 Titanium 资料就比较少。但是，在 V2EX 上关于 PhoneGap 的讨论都基本停留在它性能如何不好怎么后悔方面，但是一看发表时间好像也是 1，2 年以前的事了，这让我对此更加疑惑。按常理说，一个前端工程师肯定更加倾向于 PhoneGap ，就是一个 WebView 么，以前玩的那些都能在 App 上跑起来，多好啊。不过在深入对比过 PhoneGap 和 Titanium 的区别之后，还是抛弃了 PhoneGap ，即便 PhoneGap+Ionic+AngularJS 能够快速开发出一个复杂的、不错的应用，而 Titanium 能够开发出一个更加接近原生（Native）的 App 。</p>
<p>PhoneGap 和 Ti 之间的艰难选择的结论主要集中到以下三点：</p>
<ul>
<li><p>一是产品性能问题，虽然我没有拿 PhoneGap 来开发出一个较复杂 App ，但是之前浏览器环境下的开发经验告诉我，在一个 WebView 上开发 App ，基本上也不会避开浏览器上的那些问题，包括内容加载、状态维护、页面切换、动态效果等。</p>
</li>
<li><p>二是框架定位问题，PhoneGap 主要还是引领 W3C 标准，致力于前瞻性的开发一些 Device API ，例如 Audio、Camera、Geolocation、localStorage 等，它提供是对于这些 Device API 的 bridge 。但是，它对于 App 本身关注较少，这也注定了 PhoneGap 的目标是让 webapp 获得更多的 Device API ，而不是构建原生的 App 。具体请参见[《跨平台移动开发工具:PhoneGap与Titanium全方位比拼》]一文，原文参见[《Comparing Titanium and PhoneGap》]（很棒的一篇文章）。</p>
</li>
<li><p>三是 UI 问题，PhoneGap 本身不提供任何 UI 相关的接口，一切 UI 都由 HTML 实现，当然也出现了很多专门的 UI 框架，比较优秀的有 Ionic，Lungo，所以他开发出来的 UI 一致性很好，真的成也萧何败萧何，好坏自知。</p>
<p>Ti 并没有极力去说服开发者一套代码适用于全平台，它更加强调代码的重用度，例如 Model 代码重用度 90 %， View 层代码重用度 80 %。这与 Ti 框架的设计有关，它是一个底层 Native API 的 PORT ，当然也包括了 UI 相关的 API ，它更加接近于原生 App ，这里没有说他是原生 App 是因为它仍然是在运行时再去执行你的 JavaScript 代码，并没有直接将 JavaScript 编译到 Objective-C 或者 Java ，甚至是字节码。所以，相比原生 App 它在性能上也会打个折。</p>
</li>
</ul>
<p><img src="/images/ti-flow.png" alt="Ti Flow"></p>
<p>附图就是 Ti 框架下 JavaScript 最终如何与底层 API 交互的逻辑，Ti 就是作为 Proxy，在运行时动态解析 JavaScript 代码（在 V8/JavaScript Core 环境下），然后 Proxy 到 Ti SDK ，再 Proxy 到底层 API。</p>
<p>看来是很不错的构想，距离 JavaScript 一统天下不远了，好吧，就这么定了，撇下 PhoneGap ，搭上 Titanium。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟 PhoneGap、AppCan 类似，Appecelerator Titanium（简称&lt;strong&gt;Ti&lt;/strong&gt;）致力于使用 JavaScript 去快速构建 App ([Atwood定律]在发功)。它们有效地抚平了学习曲线，使得 App 开发不再依赖于对
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我们是一家软件公司</title>
    <link href="http://jiyee.io/2014/07/%E6%88%91%E4%BB%AC%E6%98%AF%E4%B8%80%E5%AE%B6%E8%BD%AF%E4%BB%B6%E5%85%AC%E5%8F%B8/"/>
    <id>http://jiyee.io/2014/07/我们是一家软件公司/</id>
    <published>2014-06-30T16:00:00.000Z</published>
    <updated>2016-12-23T01:16:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看 Misfit CEO 采访，他们做的是 shine 智能硬件，采访最后他定义自己是“<strong>我们是一家软件公司</strong>”。</p>
<p>好熟悉的声音，是不是乔布斯在世的时候也时常提醒我们 Apple 是一家软件公司。再回过头看 shine 的配套软件，无论从界面简洁还是操作易用方面评价，都是一款很精致的 App。</p>
<p>说过好的，当然说说那些渣的。对比国内<strong>点名时间</strong>支持的项目，智能开关、智能红外、智能体温计，暂且不论硬件产品做得怎么样，在软件设计上，国内的可穿戴硬件的 App  基本都是渣，要么下载不了 App（<em>酷狗 WiFi 音乐盒</em>），要么没有说明书（<em>BroadLink RM1</em>），要么 App 极丑且难用（<em>BroadLink RM1</em>），要么界面 UI 只有看不懂的 icon（<em>Raiing 体温贴</em>），操作极其别扭，要么毫无使用粘性（<em>Lemon 体重秤</em>）。唯一要表扬的是在 knewone 上订购的<em>幻腾世纪</em>智能灯泡，App 功能虽然比较单一，但是 App 设计体验上仍算别致。</p>
<p>为什么为写这样一篇使用体验呢，其实是最近买了<em>lumoback</em>（电子背背佳，妈妈再也不用担心我驼背了），一眼看中就海淘回来。拿到手包装背面写着 <strong><em>designed in California，made in China。。。</em></strong> 硬件本身只有一个按钮，但实际操作还是比较复杂的，好在它的设计不会让你觉得困惑，因为有说明书和 App。配套说明书一分两半，基础部分和进阶部分，是不是很有软件工程师的特色，基础部分告诉你基本使用该如何如何，进阶部分你可以进一步调校硬件，或者碰到问题的时候以供查阅。打开 App 通过蓝牙连接，那 App 上实时更新的小人，在穿戴的时候加入了娱乐性，你一驼背他立马就变化，告诉你，你小心哦，我要开始震动了。哈哈，多有意思。</p>
<p>真正用心做的产品，用户是能够感知到的。而设计先行的产品思路，从一开始就确立了产品的格调。在这里我不得不说国内产品真的是走在一条错的道路上，至少我没有耐心等你慢慢优化你 App 提升你的体验，差的第一印象可能就导致一个用户的流失。</p>
<p>最后，感谢 Apple 在 iPhone 里加入了蓝牙 4.0，让我有机会接触到更多更新奇的智能硬件，不断地去体验，不断地去判断。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看 Misfit CEO 采访，他们做的是 shine 智能硬件，采访最后他定义自己是“&lt;strong&gt;我们是一家软件公司&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;好熟悉的声音，是不是乔布斯在世的时候也时常提醒我们 Apple 是一家软件公司。再回过头看 shine 的配套
    
    </summary>
    
    
  </entry>
  
</feed>
